//// To prepare for PAT, the judge sometimes has to generate random passwords for the users. The problem is that there are always some confusing passwords since it is hard to distinguish 1 (one) from l (L in lowercase), or 0 (zero) from O (o in uppercase). One solution is to replace 1 (one) by @, 0 (zero) by %, l by L, and O by o. Now it is your job to write a program to check the accounts generated by the judge, and to help the juge modify the confusing passwords.
////
//// Input Specification:
//// Each input file contains one test case. Each case contains a positive integer N (≤1000), followed by N lines of accounts. Each account consists of a user name and a password, both are strings of no more than 10 characters with no space.
////
//// Output Specification:
//// For each test case, first print the number M of accounts that have been modified, then print in the following M lines the modified accounts info, that is, the user names and the corresponding modified passwords. The accounts must be printed in the same order as they are read in. If no account is modified, print in one line There are N accounts and no account is modified where N is the total number of accounts. However, if N is one, you must print There is 1 account and no account is modified instead.
//
//// Sample Input 1:
////  3
//// Team000002 Rlsp0dfa
//// Team000003 perfectpwd
//// Team000001 R1spOdfa
//
//// Sample Output 1:
//// 2
//// Team000002 RLsp%dfa
//// Team000001 R@spodfa
//
//// Sample Input 2:
//// 1
//// team110 abcdefg332
//
//// Sample Output 2:
//// There is 1 account and no account is modified
//
//// Sample Input 3:
//// 2
//// team110 abcdefg222
//// team220 abcdefg333
//
//// Sample Output 3:
//// There are 2 accounts and no account is modified
//
//#include <iostream>
//#include <vector>
//#include <string>
//#include <unordered_map>
//
//using namespace std;
//
//unordered_map<char,char> repla={{'1','@'},{'0','%'},{'l','L'},{'O','o'}};
//
//int nodes;string users,passw;vector<string> result;
//
//int main() {
//    cin>>nodes;
//    for(int i=0,modify=0;i<nodes;++i,modify=0) {
//        cin>>users>>passw;
//        for(int j=0;j<passw.size();++j) if(repla[passw[j]]) {passw[j]=repla[passw[j]];modify=1;}
//        if(modify) result.push_back(users+" "+passw);
//    }
//    if(result.size()) {cout<<result.size()<<"\n";for(int i=0;i<result.size();++i) cout<<result[i]<<"\n";}
//    else printf("There %s %d account%s and no account is modified",nodes==1?"is":"are",nodes,nodes==1?"":"s");
//}
//
////说明：给出若干用户名和密码，密码中可能会有一些字符如1和l，0和O形状相似，从而造成混淆，现在让你找出密码中的这些字符，把1替换成@，l替换成L，0替换成%，O替换成o，最后输出那些被修改过的密码。
//
////分析：用一个map来存相似字符与它们的替换字符，对于输入的每个密码，遍历它们的每个字符，假如有相似字符就在map中查找并替换，最后输出所有被修改过的密码。
//
////注意：当输入只有一个用户名和密码且没有被修改时，要输出is和account，多个用户名和密码且没有被修改时，要输出are和accounts。
